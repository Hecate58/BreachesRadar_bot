import os
import logging
import asyncio
from datetime import datetime

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, ContextTypes, 
    ConversationHandler, MessageHandler, filters
)

# Importer les configurations
from config import (
    TELEGRAM_BOT_TOKEN, LOG_FORMAT, LOG_LEVEL,
    CHOOSE_SEARCH, CHOOSE_SCAN, DOMAIN_INPUT, EMAIL_INPUT, 
    URL_INPUT, KEYWORD_INPUT, DORK_INPUT, GENERATE_REPORT
)

# Importer les modules utilitaires
from utils.search import search_web, search_reddit, search_github, search_google_dorks
from utils.scan import scan_domain, scan_url, scan_email
from utils.report import generate_pdf_report

# Configuration des journaux
logging.basicConfig(
    format=LOG_FORMAT,
    level=getattr(logging, LOG_LEVEL)
)
logger = logging.getLogger(__name__)

# Fonction pour crÃ©er le clavier en ligne pour la recherche
def get_search_keyboard():
    keyboard = [
        [
            InlineKeyboardButton("ğŸŒ Web", callback_data="web"),
            InlineKeyboardButton("ğŸ“± Reddit", callback_data="reddit")
        ],
        [
            InlineKeyboardButton("ğŸ’» Github", callback_data="github"),
            InlineKeyboardButton("ğŸ” Google Dorks", callback_data="dorks")
        ],
        [
            InlineKeyboardButton("âŒ Annuler", callback_data="cancel")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

# Fonction pour crÃ©er le clavier en ligne pour le scan
def get_scan_keyboard():
    keyboard = [
        [
            InlineKeyboardButton("ğŸŒ Domaine", callback_data="domain"),
            InlineKeyboardButton("ğŸ”— URL", callback_data="url")
        ],
        [
            InlineKeyboardButton("âœ‰ï¸ Email", callback_data="email"),
            InlineKeyboardButton("âŒ Annuler", callback_data="cancel")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

# Gestionnaires de commandes
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envoie un message quand la commande /start est Ã©mise"""
    user = update.effective_user
    await update.message.reply_html(
        f"ğŸŒŸ Bienvenue {user.mention_html()} ! ğŸŒŸ\n\n"
        f"ğŸ›¡ï¸ Je suis votre assistant de cybersÃ©curitÃ© personnel. Je peux vous aider Ã  trouver des informations sensibles, analyser des vulnÃ©rabilitÃ©s et gÃ©nÃ©rer des rapports dÃ©taillÃ©s.\n\n"
        f"ğŸ“‹ <b>Commandes principales:</b>\n\n"
        f"ğŸ” /recherche - Explorer le web, Reddit, GitHub ou utiliser des Google Dorks\n"
        f"ğŸ”’ /scan - Analyser la sÃ©curitÃ© d'un domaine, URL ou email\n"
        f"ğŸ“Š /rapport - GÃ©nÃ©rer un rapport PDF professionnel\n"
        f"â„¹ï¸ /aide - Afficher toutes les instructions dÃ©taillÃ©es\n\n"
        f"ğŸ” <b>PrÃªt Ã  renforcer votre sÃ©curitÃ©?</b> Commencez avec la commande /recherche ou /scan !"
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envoie un message quand la commande /aide est Ã©mise"""
    await update.message.reply_text(
        "ğŸ“š <b>GUIDE D'UTILISATION</b> ğŸ“š\n\n"
        "ğŸ” <b>RECHERCHE</b> avec /recherche\n"
        "  â€¢ ğŸŒ <b>Web</b>: recherche sans API payante\n"
        "  â€¢ ğŸ“± <b>Reddit</b>: explore les forums et discussions\n"
        "  â€¢ ğŸ’» <b>GitHub</b>: trouve des dÃ©pÃ´ts de code pertinents\n"
        "  â€¢ ğŸ” <b>Google Dorks</b>: techniques avancÃ©es de recherche\n\n"
        "ğŸ›¡ï¸ <b>SÃ‰CURITÃ‰</b> avec /scan\n"
        "  â€¢ ğŸŒ <b>Domaine</b>: WHOIS, DNS, ports ouverts, menaces\n"
        "  â€¢ ğŸ”— <b>URL</b>: analyse des en-tÃªtes, rÃ©putation, vulnÃ©rabilitÃ©s\n"
        "  â€¢ âœ‰ï¸ <b>Email</b>: validitÃ©, SPF, DMARC, sÃ©curitÃ©\n\n"
        "ğŸ“Š <b>RAPPORTS</b> avec /rapport\n"
        "  â€¢ GÃ©nÃ¨re un PDF professionnel des derniers rÃ©sultats\n"
        "  â€¢ Parfait pour documentation et partage\n\n"
        "âŒ Pour annuler Ã  tout moment, cliquez sur \"Annuler\"\n\n"
        "ğŸ’¡ <b>ASTUCE</b>: Utilisez les Google Dorks pour des recherches de sÃ©curitÃ© avancÃ©es!",
        parse_mode='HTML'
    )

async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re la commande /recherche"""
    keyboard = get_search_keyboard()
    await update.message.reply_text(
        "ğŸ” <b>MODE RECHERCHE ACTIVÃ‰</b> ğŸ”\n\n"
        "Choisissez votre mÃ©thode de recherche :\n"
        "â€¢ ğŸŒ <b>Web</b> - Recherche standard sur le web\n"
        "â€¢ ğŸ“± <b>Reddit</b> - Exploration des discussions Reddit\n"
        "â€¢ ğŸ’» <b>GitHub</b> - Recherche de code et projets\n"
        "â€¢ ğŸ” <b>Google Dorks</b> - Recherche avancÃ©e et ciblÃ©e",
        parse_mode='HTML',
        reply_markup=keyboard
    )
    return CHOOSE_SEARCH

async def scan_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re la commande /scan"""
    keyboard = get_scan_keyboard()
    await update.message.reply_text(
        "ğŸ›¡ï¸ <b>MODE ANALYSE DE SÃ‰CURITÃ‰ ACTIVÃ‰</b> ğŸ›¡ï¸\n\n"
        "Choisissez ce que vous voulez analyser :\n"
        "â€¢ ğŸŒ <b>Domaine</b> - Analyse complÃ¨te d'un domaine\n"
        "â€¢ ğŸ”— <b>URL</b> - VÃ©rification de sÃ©curitÃ© d'une URL\n"
        "â€¢ âœ‰ï¸ <b>Email</b> - Validation et analyse d'email",
        parse_mode='HTML',
        reply_markup=keyboard
    )
    return CHOOSE_SCAN

async def report_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re la commande /rapport"""
    if not context.user_data.get('last_results'):
        await update.message.reply_text(
            "âš ï¸ <b>Aucune donnÃ©e disponible</b> âš ï¸\n\n"
            "Vous devez d'abord effectuer une recherche ou un scan.\n"
            "Utilisez /recherche ou /scan pour commencer!",
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    await update.message.reply_text(
        "ğŸ“Š <b>GÃ‰NÃ‰RATION DE RAPPORT EN COURS</b> ğŸ“Š\n"
        "PrÃ©paration de votre document PDF...",
        parse_mode='HTML'
    )
    
    try:
        report_type = context.user_data.get('last_type', 'general')
        pdf_buffer = await generate_pdf_report(
            context.user_data['last_results'], 
            report_type
        )
        
        # CrÃ©er un nom de fichier personnalisÃ©
        report_type_names = {
            'search': 'recherche',
            'domain': 'domaine',
            'url': 'url',
            'email': 'email',
            'general': 'general'
        }
        
        report_name = report_type_names.get(report_type, report_type)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        await update.message.reply_document(
            document=pdf_buffer,
            filename=f"SecScan_{report_name}_{timestamp}.pdf",
            caption="ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰</b> ğŸ”’\n\nVotre analyse dÃ©taillÃ©e est prÃªte! Ce document peut Ãªtre partagÃ© ou sauvegardÃ© pour rÃ©fÃ©rence future.",
            parse_mode='HTML'
        )
    except Exception as e:
        logger.error(f"Erreur lors de la gÃ©nÃ©ration du rapport: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR</b> âŒ\n\nImpossible de gÃ©nÃ©rer le rapport: {str(e)}\n\nVeuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re les clics sur les boutons du clavier"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "cancel":
        await query.edit_message_text("OpÃ©ration annulÃ©e.")
        return ConversationHandler.END
    
    # Traiter les options de recherche
    if query.data in ["web", "reddit", "github", "dorks"]:
        context.user_data['search_type'] = query.data
        
        if query.data == "dorks":
            await query.edit_message_text(
                "Entrez votre Google Dork ou le mot-clÃ© pour lequel vous souhaitez des suggestions de dorks:"
            )
            return DORK_INPUT
        else:
            await query.edit_message_text(
                "Entrez votre mot-clÃ© ou phrase Ã  rechercher:"
            )
            return KEYWORD_INPUT
    
    # Traiter les options de scan
    if query.data in ["domain", "url", "email"]:
        context.user_data['scan_type'] = query.data
        
        if query.data == "domain":
            await query.edit_message_text(
                "Entrez le nom de domaine Ã  scanner (ex: example.com):"
            )
            return DOMAIN_INPUT
        elif query.data == "url":
            await query.edit_message_text(
                "Entrez l'URL complÃ¨te Ã  scanner (ex: https://example.com/page):"
            )
            return URL_INPUT
        elif query.data == "email":
            await query.edit_message_text(
                "Entrez l'adresse email Ã  analyser:"
            )
            return EMAIL_INPUT

async def domain_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du domaine"""
    domain = update.message.text.strip()
    
    # Validation basique du domaine
    import re
    domain_regex = r'^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'\'()*+,;=:]*)*
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()


async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END\'()*+,;=:]*)*

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    # Messages personnalisÃ©s selon le type de recherche
    search_icons = {
        'web': 'ğŸŒ',
        'reddit': 'ğŸ“±',
        'github': 'ğŸ’»',
        'dorks': 'ğŸ”'
    }
    
    search_names = {
        'web': 'Web',
        'reddit': 'Reddit',
        'github': 'GitHub',
        'dorks': 'Google Dorks'
    }
    
    icon = search_icons.get(search_type, 'ğŸ”')
    name = search_names.get(search_type, 'Inconnu')
    
    await update.message.reply_text(
        f"{icon} <b>RECHERCHE {name.upper()}</b> {icon}\n\n"
        f"RequÃªte: <code>{keyword}</code>\n"
        f"<i>Recherche en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte avec des dÃ©tails sur la recherche
        header = f"{icon} <b>RÃ‰SULTATS DE RECHERCHE {name.upper()}</b> {icon}\n\n"
        header += f"<b>RequÃªte:</b> <code>{keyword}</code>\n"
        header += f"<b>RÃ©sultats trouvÃ©s:</b> <code>{len(results)}</code>\n\n"
        
        # Formater les rÃ©sultats avec HTML pour une meilleure prÃ©sentation
        result_sections = []
        
        for idx, result in enumerate(results, 1):
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            url = result.get('url', '')
            snippet = result.get('snippet', 'Pas de description disponible')
            
            # Coloration spÃ©ciale pour les sources
            source_colored = source
            if 'Error' in source:
                source_colored = f"âš ï¸ {source}"
            
            section = f"<b>{idx}. {title}</b>\n"
            section += f"<i>Source: {source_colored}</i>\n"
            
            if url:
                # Formater les URLs longues
                display_url = url
                if len(url) > 40:
                    display_url = url[:37] + "..."
                section += f"ğŸ”— <code>{display_url}</code>\n"
            
            # Formater le snippet
            if snippet:
                # Limiter la longueur du snippet pour l'affichage
                if len(snippet) > 200:
                    snippet = snippet[:197] + "..."
                section += f"{snippet}\n"
            
            result_sections.append(section)
        
        # Ajouter des astuces ou des suggestions basÃ©es sur le type de recherche
        footer = "\n<b>ğŸ“Œ ASTUCES:</b>\n"
        
        if search_type == 'web':
            footer += "â€¢ Essayez d'utiliser des mots-clÃ©s plus spÃ©cifiques pour affiner vos rÃ©sultats\n"
            footer += "â€¢ Utilisez des guillemets pour rechercher une expression exacte\n"
        elif search_type == 'reddit':
            footer += "â€¢ PrÃ©fixez votre recherche avec 'subreddit:' pour cibler un subreddit spÃ©cifique\n"
            footer += "â€¢ Utilisez 'author:' pour trouver les publications d'un utilisateur spÃ©cifique\n"
        elif search_type == 'github':
            footer += "â€¢ Ajoutez 'language:python' (ou autre langage) pour filtrer par type de code\n"
            footer += "â€¢ Utilisez 'stars:>100' pour trouver des dÃ©pÃ´ts populaires\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser un Ã©lÃ©ment spÃ©cifique"
        
        # Assembler le message final
        response = header + "\n".join(result_sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            first_part = header + "<i>Les rÃ©sultats suivent dans plusieurs messages...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser les rÃ©sultats en morceaux
            chunks = []
            current_chunk = ""
            
            for section in result_sections:
                if len(current_chunk) + len(section) > 3800:
                    chunks.append(current_chunk)
                    current_chunk = section + "\n"
                else:
                    current_chunk += section + "\n"
            
            if current_chunk:
                chunks.append(current_chunk)
            
            # Envoyer les morceaux
            for i, chunk in enumerate(chunks):
                if i == len(chunks) - 1:
                    # Dernier morceau avec le footer
                    await update.message.reply_text(chunk + footer, parse_mode='HTML')
                else:
                    await update.message.reply_text(chunk, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR DE RECHERCHE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de la recherche {name}:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer avec d'autres termes ou options.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE GOOGLE DORK</b> ğŸ”\n\n"
        f"RequÃªte: <code>{dork}</code>\n"
        f"<i>Analyse en cours, veuillez patienter...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # En-tÃªte dÃ©taillÃ©
        header = f"ğŸ” <b>ANALYSE GOOGLE DORK</b> ğŸ”\n\n"
        header += f"<b>Dork analysÃ©:</b> <code>{dork}</code>\n\n"
        
        # DÃ©tection des opÃ©rateurs dans la requÃªte pour l'affichage
        operators = ["site:", "inurl:", "intitle:", "filetype:", "intext:", "ext:"]
        detected = [op for op in operators if op in dork]
        
        if detected:
            header += f"<b>OpÃ©rateurs dÃ©tectÃ©s:</b> <code>{', '.join(detected)}</code>\n\n"
        
        header += "<b>ğŸ“‹ COMMENT UTILISER LES DORKS:</b>\n"
        header += "Les Google Dorks sont des requÃªtes spÃ©cialisÃ©es pour cibler prÃ©cisÃ©ment des informations sur le web. "
        header += "Utilisez-les avec prÃ©caution et Ã©thique.\n\n"
        
        # Formater chaque section de rÃ©sultat avec du HTML pour une meilleure prÃ©sentation
        sections = []
        
        for result in results:
            title = result.get('title', 'Sans titre')
            source = result.get('source', 'Source inconnue')
            snippet = result.get('snippet', 'Pas d\'information disponible').replace('\n', '<br>')
            
            section = f"<b>ğŸ“Œ {title}</b> <i>({source})</i>\n"
            section += f"{snippet}\n"
            
            sections.append(section)
        
        # Ajouter une section d'exemples pratiques
        examples_section = "<b>ğŸ” EXEMPLES PRATIQUES DE DORKS:</b>\n"
        examples_section += "<pre>"
        examples_section += "site:example.com filetype:pdf       # PDFs sur un site\n"
        examples_section += "intitle:\"Index of\" site:example.com # Dossiers ouverts\n"
        examples_section += "site:example.com intext:password    # Cherche mots de passe\n"
        examples_section += "site:example.com ext:sql OR ext:log # Fichiers sensibles\n"
        examples_section += "</pre>"
        
        # Ajouter des recommendations de sÃ©curitÃ©
        footer = "\n<b>ğŸ” RECOMMANDATIONS DE SÃ‰CURITÃ‰:</b>\n"
        footer += "â€¢ Utilisez ces techniques pour vÃ©rifier la sÃ©curitÃ© de vos propres ressources\n"
        footer += "â€¢ Si vous trouvez des informations sensibles exposÃ©es, contactez immÃ©diatement le responsable du site\n"
        footer += "â€¢ L'utilisation malveillante de Google Dorks peut Ãªtre illÃ©gale et Ã©thiquement rÃ©prÃ©hensible\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF de ces rÃ©sultats\n"
        footer += "â€¢ /recherche - Effectuer une nouvelle recherche\n"
        footer += "â€¢ /scan - Analyser plus en profondeur"
        
        # Assembler le message final
        response = header + "\n\n".join(sections) + "\n\n" + examples_section + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec l'en-tÃªte
            await update.message.reply_text(header, parse_mode='HTML')
            
            # Message principal avec les sections de rÃ©sultats
            sections_text = "\n\n".join(sections)
            
            # Diviser si nÃ©cessaire
            if len(sections_text) > 3800:
                for i in range(0, len(sections_text), 3800):
                    await update.message.reply_text(sections_text[i:i+3800], parse_mode='HTML')
            else:
                await update.message.reply_text(sections_text, parse_mode='HTML')
            
            # Dernier message avec exemples et footer
            await update.message.reply_text(examples_section + footer, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du Google Dork:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier la syntaxe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(email_regex, email):
        await update.message.reply_text(
            "âš ï¸ <b>EMAIL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'adresse email n'est pas valide.\n"
            "Veuillez entrer une adresse au format correct (ex: utilisateur@domaine.com)",
            parse_mode='HTML'
        )
        return EMAIL_INPUT
    
    # Extraire le domaine pour l'affichage
    domain = email.split('@')[1]
    
    await update.message.reply_text(
        f"âœ‰ï¸ <b>ANALYSE EMAIL EN COURS</b> âœ‰ï¸\n\n"
        f"Adresse: <code>{email}</code>\n"
        f"Domaine: <code>{domain}</code>\n\n"
        f"<b>VÃ©rifications en cours:</b>\n"
        f"â€¢ Format et syntaxe\n"
        f"â€¢ Configuration du domaine\n"
        f"â€¢ Enregistrements MX\n"
        f"â€¢ Protection SPF/DMARC\n\n"
        f"<i>Veuillez patienter pendant l'analyse...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Trouver les informations importantes pour l'affichage
        format_check = next((r for r in results if r.get('title') == 'Validation du format'), None)
        domain_check = next((r for r in results if r.get('title') == 'Validation du domaine'), None)
        mx_check = next((r for r in results if r.get('title') == 'Enregistrements MX'), None)
        spf_check = next((r for r in results if r.get('title') == 'Enregistrement SPF'), None)
        dmarc_check = next((r for r in results if r.get('title') == 'Enregistrement DMARC'), None)
        
        # Construire l'en-tÃªte
        header = f"âœ‰ï¸ <b>RAPPORT D'ANALYSE EMAIL</b> âœ‰ï¸\n"
        header += f"<b>Adresse:</b> <code>{email}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© de sÃ©curitÃ©
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DE SÃ‰CURITÃ‰:</b>\n"
        
        # VÃ©rifier si le domaine peut recevoir des emails
        domain_status = "âš ï¸ ProblÃ¨mes dÃ©tectÃ©s"
        if domain_check:
            status = domain_check.get('details', {}).get('status', '')
            if 'peut recevoir' in status:
                domain_status = "âœ… Fonctionnel"
        summary += f"â€¢ <b>RÃ©ception d'emails:</b> {domain_status}\n"
        
        # VÃ©rifier SPF
        spf_status = "âŒ Non configurÃ©"
        if spf_check:
            if 'warning' not in spf_check.get('details', {}):
                spf_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection SPF:</b> {spf_status}\n"
        
        # VÃ©rifier DMARC
        dmarc_status = "âŒ Non configurÃ©"
        if dmarc_check:
            if 'warning' not in dmarc_check.get('details', {}):
                dmarc_status = "âœ… ConfigurÃ©"
        summary += f"â€¢ <b>Protection DMARC:</b> {dmarc_status}\n"
        
        # Indicateur de sÃ©curitÃ© global
        security_level = "ğŸ”´ Faible"
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¢ Ã‰levÃ©"
        elif spf_status == "âœ… ConfigurÃ©" or dmarc_status == "âœ… ConfigurÃ©":
            security_level = "ğŸŸ¡ Moyen"
        summary += f"â€¢ <b>Niveau de sÃ©curitÃ©:</b> {security_level}\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Ajouter chaque section de rÃ©sultat avec une mise en forme amÃ©liorÃ©e
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Coloration spÃ©cifique pour les statuts
                        if 'warning' in key or 'error' in key:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif 'status' in key and 'peut recevoir' in str(value):
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif key == 'spf_record' or key == 'dmarc_record':
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                        elif 'info' in key:
                            section += f"  â€¢ <b>{key}:</b> â„¹ï¸ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des recommandations basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        
        if spf_status == "âŒ Non configurÃ©":
            footer += "â€¢ Configurez un enregistrement SPF pour ce domaine\n"
        
        if dmarc_status == "âŒ Non configurÃ©":
            footer += "â€¢ Ajoutez un enregistrement DMARC pour amÃ©liorer la sÃ©curitÃ©\n"
        
        if spf_status == "âœ… ConfigurÃ©" and dmarc_status == "âœ… ConfigurÃ©":
            footer += "â€¢ Excellent! Ce domaine est bien protÃ©gÃ© contre l'usurpation d'identitÃ©\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'email:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que le domaine existe et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(url_regex, url):
        await update.message.reply_text(
            "âš ï¸ <b>URL INVALIDE</b> âš ï¸\n\n"
            "Le format de l'URL n'est pas valide.\n"
            "Veuillez entrer une URL complÃ¨te commenÃ§ant par http:// ou https:// (ex: https://example.com)",
            parse_mode='HTML'
        )
        return URL_INPUT
    
    # Afficher un message pendant l'analyse
    await update.message.reply_text(
        f"ğŸ” <b>ANALYSE DE SÃ‰CURITÃ‰ URL</b> ğŸ”\n\n"
        f"Cible: <code>{url}</code>\n\n"
        f"<b>OpÃ©rations en cours:</b>\n"
        f"â€¢ VÃ©rification des en-tÃªtes de sÃ©curitÃ©\n"
        f"â€¢ Analyse des redirections\n"
        f"â€¢ Recherche de vulnÃ©rabilitÃ©s\n"
        f"â€¢ Scan de rÃ©putation\n\n"
        f"<i>Cette opÃ©ration peut prendre quelques instants...</i>",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Trouver les informations importantes pour le rÃ©sumÃ©
        headers_data = next((r for r in results if r.get('title') == 'En-tÃªtes de sÃ©curitÃ©'), None)
        security_check = next((r for r in results if r.get('title') == 'Ã‰valuation de sÃ©curitÃ©'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        
        # Construire l'en-tÃªte avec l'URL raccourcie pour l'affichage
        display_url = url
        if len(url) > 40:
            display_url = url[:37] + "..."
        
        header = f"ğŸ›¡ï¸ <b>ANALYSE DE SÃ‰CURITÃ‰ WEB</b> ğŸ›¡ï¸\n"
        header += f"<b>URL:</b> <code>{display_url}</code>\n\n"
        
        # CrÃ©er un rÃ©sumÃ© visuel
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ DES RÃ‰SULTATS:</b>\n"
        
        # Ã‰valuation de sÃ©curitÃ©
        security_score = "N/A"
        if security_check:
            security_score = security_check.get('details', {}).get('score', "N/A")
            recommendations = security_check.get('details', {}).get('recommandations', [])
            
            # Convertir le score en reprÃ©sentation visuelle
            if security_score != "N/A":
                score_rating = ""
                score_num = int(security_score.split('/')[0])
                if score_num == 4:
                    score_rating = "ğŸŸ¢ Excellent"
                elif score_num == 3:
                    score_rating = "ğŸŸ¢ Bon"
                elif score_num == 2:
                    score_rating = "ğŸŸ¡ Moyen"
                elif score_num == 1:
                    score_rating = "ğŸ”´ Faible"
                else:
                    score_rating = "ğŸ”´ Critique"
                
                summary += f"â€¢ <b>Score de sÃ©curitÃ©:</b> {score_rating} ({security_score})\n"
            
            if recommendations and len(recommendations) > 0:
                summary += f"â€¢ <b>ProblÃ¨mes dÃ©tectÃ©s:</b> <code>{len(recommendations)}</code>\n"
        
        # VirusTotal 
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            if int(malicious) > 0:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸ”´ <code>{malicious} dÃ©tections de menaces</code>\n"
            else:
                summary += f"â€¢ <b>RÃ©putation:</b> ğŸŸ¢ <code>Aucune menace dÃ©tectÃ©e</code>\n"
        
        # Construire les sections dÃ©taillÃ©es
        sections = []
        
        # Section pour chaque rÃ©sultat
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if key == 'recommandations' and isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b>\n"
                        for i, rec in enumerate(value, 1):
                            section += f"    {i}. <code>{rec}</code>\n"
                    elif isinstance(value, list):
                        section += f"  â€¢ <b>{key}:</b> <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Mise en forme spÃ©ciale pour certains en-tÃªtes
                        if result['title'] == 'En-tÃªtes de sÃ©curitÃ©':
                            # Colorer les en-tÃªtes selon leur prÃ©sence
                            if key in ['Strict-Transport-Security', 'Content-Security-Policy', 'X-Content-Type-Options', 'X-Frame-Options']:
                                if 'Non prÃ©sent' in str(value):
                                    section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                                else:
                                    section += f"  â€¢ <b>{key}:</b> ğŸŸ¢ <code>{value}</code>\n"
                            else:
                                section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
                        # Coloration pour les rÃ©sultats de VirusTotal
                        elif key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}:</b> ğŸ”´ <code>{value}</code>\n"
                        elif key in ['suspicious', 'warning', 'error'] and value:
                            section += f"  â€¢ <b>{key}:</b> ğŸŸ¡ <code>{value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}:</b> <code>{value}</code>\n"
            
            sections.append(section)
        
        # Ajouter des suggestions basÃ©es sur les rÃ©sultats
        footer = "\n<b>ğŸ”§ RECOMMANDATIONS:</b>\n"
        if security_check and 'details' in security_check and 'recommandations' in security_check['details']:
            recs = security_check['details']['recommandations']
            if recs and len(recs) > 0:
                footer += "<i>Pour amÃ©liorer la sÃ©curitÃ©:</i>\n"
                for i, rec in enumerate(recs[:3], 1):  # Limiter Ã  3 recommandations pour la lisibilitÃ©
                    footer += f"{i}. {rec}\n"
                if len(recs) > 3:
                    footer += f"<i>+ {len(recs) - 3} autres recommandations dans le rapport dÃ©taillÃ©</i>\n"
            else:
                footer += "âœ… <i>Cette URL semble bien configurÃ©e pour la sÃ©curitÃ©!</i>\n"
        
        footer += "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Analyser une autre cible\n"
        footer += "â€¢ /recherche - Rechercher plus d'informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse de l'URL:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez vÃ©rifier que l'URL est accessible et rÃ©essayer.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()

    if not re.match(domain_regex, domain, re.IGNORECASE):
        await update.message.reply_text(
            "âš ï¸ <b>FORMAT INVALIDE</b> âš ï¸\n\n"
            "Le format du domaine n'est pas valide.\n"
            "Veuillez entrer un domaine au format correct (ex: example.com):",
            parse_mode='HTML'
        )
        return DOMAIN_INPUT
    
    await update.message.reply_text(
        f"ğŸ”„ <b>ANALYSE EN COURS</b> ğŸ”„\n\n"
        f"Domaine cible: <code>{domain}</code>\n"
        f"â€¢ RÃ©cupÃ©ration des informations WHOIS\n"
        f"â€¢ Analyse des enregistrements DNS\n"
        f"â€¢ VÃ©rification des ports ouverts\n"
        f"â€¢ Recherche de menaces connues\n\n"
        f"Veuillez patienter...",
        parse_mode='HTML'
    )
    
    try:
        results = await scan_domain(domain)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'domain'
        
        # Formater les rÃ©sultats avec une meilleure prÃ©sentation
        header = f"ğŸ”’ <b>RAPPORT DE SÃ‰CURITÃ‰: {domain}</b> ğŸ”’\n\n"
        
        # Ajouter un rÃ©sumÃ© rapide
        whois_data = next((r for r in results if r.get('title') == 'Informations WHOIS'), None)
        dns_data = next((r for r in results if r.get('title') == 'Enregistrements DNS'), None)
        vt_data = next((r for r in results if r.get('title') == 'Analyse VirusTotal'), None)
        ports_data = next((r for r in results if r.get('title') == 'Ports ouverts'), None)
        
        summary = "<b>ğŸ“ RÃ‰SUMÃ‰ RAPIDE:</b>\n"
        if whois_data:
            registrar = whois_data.get('details', {}).get('registrar', 'Non disponible')
            creation = whois_data.get('details', {}).get('creation_date', 'Non disponible')
            summary += f"â€¢ Registrar: <code>{registrar}</code>\n"
            summary += f"â€¢ CrÃ©ation: <code>{creation[:10] if len(creation) > 10 else creation}</code>\n"
        
        if dns_data:
            a_records = dns_data.get('details', {}).get('A', ['Non disponible'])
            summary += f"â€¢ Adresse IP: <code>{a_records[0] if a_records else 'Non disponible'}</code>\n"
        
        if vt_data:
            malicious = vt_data.get('details', {}).get('malicious', 0)
            summary += f"â€¢ Menaces dÃ©tectÃ©es: <code>{malicious}</code>\n"
        
        if ports_data:
            open_ports = ports_data.get('details', {}).get('open_ports', [])
            if isinstance(open_ports, list) and open_ports:
                summary += f"â€¢ Ports ouverts: <code>{len(open_ports)}</code>\n"
        
        # Construire le message complet section par section
        sections = []
        
        # Parcourir chaque catÃ©gorie de rÃ©sultats
        for result in results:
            section = f"<b>ğŸ“Œ {result['title']}</b> <i>({result['source']})</i>\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        section += f"  â€¢ <b>{key}</b>: <code>{', '.join(str(v) for v in value)}</code>\n"
                    else:
                        # Colorer certains rÃ©sultats importants
                        if key == 'malicious' and int(value) > 0:
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        elif key == 'warning' or key == 'error':
                            section += f"  â€¢ <b>{key}</b>: <code>âš ï¸ {value}</code>\n"
                        else:
                            section += f"  â€¢ <b>{key}</b>: <code>{value}</code>\n"
            
            sections.append(section)
        
        footer = "\n<b>ğŸ“Š ACTIONS POSSIBLES:</b>\n"
        footer += "â€¢ /rapport - GÃ©nÃ©rer un PDF dÃ©taillÃ©\n"
        footer += "â€¢ /scan - Lancer une autre analyse\n"
        footer += "â€¢ /recherche - Rechercher des informations"
        
        # Assembler le message final
        response = header + summary + "\n\n" + "\n\n".join(sections) + "\n" + footer
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Premier message avec entÃªte et rÃ©sumÃ©
            first_part = header + summary + "\n\n<i>Suite dans le prochain message...</i>"
            await update.message.reply_text(first_part, parse_mode='HTML')
            
            # Diviser le reste en morceaux
            remaining = "\n\n".join(sections) + "\n" + footer
            for i in range(0, len(remaining), 3800):
                part = remaining[i:i+3800]
                if i + 3800 >= len(remaining):
                    part += "\n" + footer
                await update.message.reply_text(part, parse_mode='HTML')
        else:
            await update.message.reply_text(response, parse_mode='HTML')
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du domaine: {str(e)}")
        await update.message.reply_text(
            f"âŒ <b>ERREUR D'ANALYSE</b> âŒ\n\n"
            f"Une erreur s'est produite lors de l'analyse du domaine:\n"
            f"<code>{str(e)}</code>\n\n"
            f"Veuillez rÃ©essayer ou contacter l'administrateur.",
            parse_mode='HTML'
        )
    
    return ConversationHandler.END

async def url_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'URL"""
    url = update.message.text.strip()
    
    # Validation basique de l'URL
    import re
    url_regex = r'^https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+(/[-\w%!$&\'()*+,;=:]*)*$'
    if not re.match(url_regex, url):
        await update.message.reply_text(
            "Le format de l'URL semble incorrect. Veuillez entrer une URL valide (ex: https://example.com):"
        )
        return URL_INPUT
    
    await update.message.reply_text(f"Analyse de l'URL {url} en cours...")
    
    try:
        results = await scan_url(url)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'url'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {url}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'URL: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def email_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e de l'email"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    import re
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        await update.message.reply_text(
            "Le format de l'email semble incorrect. Veuillez entrer un email valide (ex: user@example.com):"
        )
        return EMAIL_INPUT
    
    await update.message.reply_text(f"Analyse de l'email {email} en cours...")
    
    try:
        results = await scan_email(email)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'email'
        
        # Formater les rÃ©sultats
        response = f"ğŸ“Š RÃ©sultats de l'analyse pour {email}:\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result['title']} ({result['source']})\n"
            
            if 'details' in result:
                for key, value in result['details'].items():
                    if isinstance(value, list):
                        response += f"  â€¢ {key}: {', '.join(value)}\n"
                    else:
                        response += f"  â€¢ {key}: {value}\n"
            
            response += "\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse de l'email: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def keyword_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du mot-clÃ© de recherche"""
    keyword = update.message.text.strip()
    search_type = context.user_data.get('search_type', 'web')
    
    await update.message.reply_text(f"Recherche de '{keyword}' en cours...")
    
    try:
        if search_type == 'web':
            results = await search_web(keyword)
        elif search_type == 'reddit':
            results = await search_reddit(keyword)
        elif search_type == 'github':
            results = await search_github(keyword)
        else:
            results = [{'title': 'Erreur', 'snippet': "Type de recherche non reconnu", 'source': 'Error'}]
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” RÃ©sultats de recherche pour '{keyword}':\n\n"
        
        for idx, result in enumerate(results, 1):
            response += f"{idx}. {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            if 'url' in result and result['url']:
                response += f"   URL: {result['url']}\n"
            response += f"   {result.get('snippet', 'Pas de description disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        if len(response) > 4096:
            # Si le message est trop long, l'envoyer en plusieurs parties
            for i in range(0, len(response), 4096):
                await update.message.reply_text(response[i:i+4096])
        else:
            await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de la recherche: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de la recherche: {str(e)}"
        )
    
    return ConversationHandler.END

async def dork_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re l'entrÃ©e du Google Dork"""
    dork = update.message.text.strip()
    
    await update.message.reply_text(f"Analyse du dork '{dork}' en cours...")
    
    try:
        results = await search_google_dorks(dork)
        
        # Enregistrer les rÃ©sultats pour la gÃ©nÃ©ration de rapport
        context.user_data['last_results'] = results
        context.user_data['last_type'] = 'search'
        
        # Formater les rÃ©sultats
        response = f"ğŸ” Analyse du Google Dork: '{dork}'\n\n"
        
        for result in results:
            response += f"ğŸ“Œ {result.get('title', 'Sans titre')} ({result.get('source', 'Source inconnue')})\n"
            response += f"{result.get('snippet', 'Pas d\'information disponible')}\n\n"
        
        response += "Utilisez /rapport pour gÃ©nÃ©rer un PDF dÃ©taillÃ©."
        
        # Envoyer les rÃ©sultats
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du dork: {str(e)}")
        await update.message.reply_text(
            f"Une erreur s'est produite lors de l'analyse: {str(e)}"
        )
    
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule et termine la conversation"""
    await update.message.reply_text(
        "âŒ <b>OPÃ‰RATION ANNULÃ‰E</b> âŒ\n\n"
        "Que souhaitez-vous faire maintenant?\n\n"
        "ğŸ” /recherche - Explorer des informations\n"
        "ğŸ›¡ï¸ /scan - Analyser la sÃ©curitÃ©\n"
        "ğŸ“Š /rapport - GÃ©nÃ©rer un rapport\n"
        "â„¹ï¸ /aide - Voir les instructions",
        parse_mode='HTML'
    )
    return ConversationHandler.END

def main():
    """Fonction principale pour dÃ©marrer le bot"""
    # VÃ©rifier si le token du bot est configurÃ©
    if TELEGRAM_BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("Veuillez configurer votre token de bot Telegram dans config.py ou via les variables d'environnement!")
        return
    
    # CrÃ©er l'application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Conversation handler pour la recherche
    search_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("recherche", search_command)],
        states={
            CHOOSE_SEARCH: [CallbackQueryHandler(button_handler)],
            KEYWORD_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, keyword_input_handler)],
            DORK_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, dork_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Conversation handler pour le scan
    scan_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("scan", scan_command)],
        states={
            CHOOSE_SCAN: [CallbackQueryHandler(button_handler)],
            DOMAIN_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, domain_input_handler)],
            URL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, url_input_handler)],
            EMAIL_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, email_input_handler)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("aide", help_command))
    application.add_handler(CommandHandler("rapport", report_command))
    application.add_handler(search_conv_handler)
    application.add_handler(scan_conv_handler)
    
    # DÃ©marrer le bot
    print("ğŸš€ Bot de SÃ©curitÃ© et Recherche dÃ©marrÃ©! ğŸ›¡ï¸")
    print("ğŸ“‹ Commandes disponibles: /start, /recherche, /scan, /rapport, /aide")
    print("ğŸ“Š PrÃªt Ã  recevoir des demandes...")
    application.run_polling()

if __name__ == "__main__":
    main()